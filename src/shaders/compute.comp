#version 450
#extension GL_ARB_separate_shader_objects : enable

#define WORKGROUP_SIZE 32
layout(local_size_x = WORKGROUP_SIZE, local_size_y = 1, local_size_z = 1) in;

layout(set = 0, binding = 0) uniform CameraBufferObject {
    mat4 view;
    mat4 proj;
	vec4 viewDir;
	vec4 viewPos;
} camera;

layout(set = 1, binding = 0) uniform Time {
    float deltaTime;
    float totalTime;
};

struct Blade {
    vec4 v0;
    vec4 v1;
    vec4 v2;
    vec4 up;
};

layout(std140,set = 2, binding = 0) buffer BladeBuffer{
	Blade blades[];
} bladeBuffer;

layout(std140,set = 2, binding = 1) buffer CulledBladeBuffer{
	Blade culledBlades[];
} culledBladesBuffer;

// TODO: Add bindings to:
// 1. Store the input blades
// 2. Write out the culled blades
// 3. Write the total number of blades remaining

// The project is using vkCmdDrawIndirect to use a buffer as the arguments for a draw call
// This is sort of an advanced feature so we've showed you what this buffer should look like
//
layout(std140,set = 2, binding = 2) buffer NumBlades {
	  uint vertexCount;   // Write the number of blades remaining here
	  uint instanceCount; // = 1
	  uint firstVertex;   // = 0
	  uint firstInstance; // = 0
} numBlades;

layout(set = 2, binding = 3) uniform Params {
	vec4 windDirection;
	vec4 lod;
	vec4 switches; // distance, frustum, direction, LOD
	float windNoiseScale;
	float windStrength;
	float gravityStrength;
	float cullingScale;
	float cullingDistance;
} params;

bool inBounds(float value, float bounds) {
    return (value >= -bounds) && (value <= bounds);
}

// https://www.shadertoy.com/view/XsX3zB
/* discontinuous pseudorandom uniformly distributed in [-0.5, +0.5]^3 */
vec3 random3(vec3 c) {
	float j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));
	vec3 r;
	r.z = fract(512.0*j);
	j *= .125;
	r.x = fract(512.0*j);
	j *= .125;
	r.y = fract(512.0*j);
	return r-0.5;
}

/* skew constants for 3d simplex functions */
const float F3 =  0.3333333;
const float G3 =  0.1666667;

/* 3d simplex noise */
float simplex3d(vec3 p) {
	 /* 1. find current tetrahedron T and it's four vertices */
	 /* s, s+i1, s+i2, s+1.0 - absolute skewed (integer) coordinates of T vertices */
	 /* x, x1, x2, x3 - unskewed coordinates of p relative to each of T vertices*/
	 
	 /* calculate s and x */
	 vec3 s = floor(p + dot(p, vec3(F3)));
	 vec3 x = p - s + dot(s, vec3(G3));
	 
	 /* calculate i1 and i2 */
	 vec3 e = step(vec3(0.0), x - x.yzx);
	 vec3 i1 = e*(1.0 - e.zxy);
	 vec3 i2 = 1.0 - e.zxy*(1.0 - e);
	 	
	 /* x1, x2, x3 */
	 vec3 x1 = x - i1 + G3;
	 vec3 x2 = x - i2 + 2.0*G3;
	 vec3 x3 = x - 1.0 + 3.0*G3;
	 
	 /* 2. find four surflets and store them in d */
	 vec4 w, d;
	 
	 /* calculate surflet weights */
	 w.x = dot(x, x);
	 w.y = dot(x1, x1);
	 w.z = dot(x2, x2);
	 w.w = dot(x3, x3);
	 
	 /* w fades from 0.6 at the center of the surflet to 0.0 at the margin */
	 w = max(0.6 - w, 0.0);
	 
	 /* calculate surflet components */
	 d.x = dot(random3(s), x);
	 d.y = dot(random3(s + i1), x1);
	 d.z = dot(random3(s + i2), x2);
	 d.w = dot(random3(s + 1.0), x3);
	 
	 /* multiply d by w^4 */
	 w *= w;
	 w *= w;
	 d *= w;
	 
	 /* 3. return the sum of the four surflets */
	 return dot(d, vec4(52.0));
}


void main() {
	// Reset the number of blades to 0
	if (gl_GlobalInvocationID.x == 0) {
		// numBlades.vertexCount = 0;
	}
	barrier(); // Wait till all threads reach this point

    // TODO: Apply forces on every blade and update the vertices in the buffer
	Blade blade = bladeBuffer.blades[gl_GlobalInvocationID.x];
	// Simple physics: apply wind force to the top vertex
	vec3 v0 = blade.v0.xyz;
	vec3 v1 = blade.v1.xyz;
	vec3 v2 = blade.v2.xyz;
	vec3 up = blade.up.xyz;
	vec3 uvw = v0;
	uvw += totalTime * params.windDirection.xyz* params.windDirection.w / params.windStrength;
	vec3 windForce = vec3(simplex3d(params.windNoiseScale*uvw), 
		0.,
		simplex3d(params.windNoiseScale*(uvw+vec3(114.,514., 0.))))*params.windStrength;
	float height = blade.v1.w;
	float width = blade.v2.w;
	float stiffness = blade.up.w;
	float directionRad = blade.v0.w;
    vec3 t1 = vec3(sin(directionRad), 0., -cos(directionRad));
	float fd = 1. - abs(dot(normalize(windForce), normalize(v2 - v0)));
	float fr = dot(v2 - v0, up) / height;
	vec3 windEffect = windForce * fd * fr * deltaTime;
	vec3 resistance = (height * up + v0 - v2) * stiffness * deltaTime;
	float gravityEffect = params.gravityStrength;
	vec3 ge = -gravityEffect * up;
	vec3 f = cross(t1, up);
	vec3 gf = .25 * -gravityEffect * normalize(f);
	v2 += windEffect;
	v2 += (ge+gf) * deltaTime;
	v2 += resistance;
	// State Validation
	v2 = v2 - up * min(dot(v2 - v0, up), 0.); // Project onto plane orthogonal to up vector
	float l_proj = length(v2 - v0 - up * dot(v2 - v0, normalize(up)));
	v1 = v0 + height * up * max(1. - l_proj / height, 0.05 * max(l_proj/height, 1.));
	float L = (2 * length(v2 - v0) + length(v1 - v0) + length(v2 - v1)) / 3.;
	v1 = v0 + height / L * (v1 - v0);
	v2 = v1 + height / L * (v2 - v1);
	blade.v1 = vec4(v1, height);
	blade.v2 = vec4(v2, width);
	// Update the blade in the buffer
	bladeBuffer.blades[gl_GlobalInvocationID.x] = blade;
	// TODO: Cull blades that are too far away or not in the camera frustum and write them
	// to the culled blades buffer
	// Note: to do this, you will need to use an atomic operation to read and update numBlades.vertexCount
	// You want to write the visible blades to the buffer without write conflicts between threads
	// Direction Culling
	if(params.switches.z > 0.){
		vec3 grassViewDir = normalize(blade.v0.xyz - camera.viewPos.xyz);
		if(abs(dot(t1, grassViewDir))>0.98){
			return;
		}
	}

	// Frustum Culling (Approximate with bounding sphere)
	if(params.switches.y > 0.){
		vec4 p0 = camera.proj * camera.view * vec4(v0, 1.);
		vec4 p2 = camera.proj * camera.view * vec4(v2, 1.);
		vec4 p1 = camera.proj * camera.view * vec4(0.25*v0+0.5*v1+0.25*v2, 1.);
		float tolerance = params.cullingScale;
		if((!inBounds(p0.x/p0.w,tolerance) || !inBounds(p0.y/p0.w,tolerance)) 
		&& (!inBounds(p1.x/p1.w,tolerance) || !inBounds(p1.y/p1.w,tolerance)) 
		&&(!inBounds(p2.x/p2.w,tolerance) || !inBounds(p2.y/p2.w,tolerance)) ){
			return;
		}
	}
	if(params.switches.x > 0.){
		float d_proj = length(camera.viewPos.xyz - v0);
		if(d_proj > params.cullingDistance){
			return;
		}
	}
	
	// Write the blade to the culled blades buffer
	uint previousValue = atomicAdd(numBlades.vertexCount, 1);
	culledBladesBuffer.culledBlades[previousValue] = blade;
	//culledBladesBuffer.culledBlades[gl_GlobalInvocationID.x] = blade;
}
